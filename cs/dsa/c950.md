# C950 Data Structures and Algorithms 2

## 2 - Algorithm analysis

### 2.1 Relation between data structures and algorithms

- Algorithmns to implement operations (i.e. insert, remove, etc) performed on data structure are specific to each data structure
  - Appending an item to a linked list requires a different algorithm than appending an item to an array

- Algorithms utilize data structures to store and organize data during algorithm execution

### 2.2 Constant time operations

**constant time operation**
- operation that for a given processor, always operates in the same amount of time, regardless of input values
- algorithm analysis describes runtime int terms of constant time operation rather than time since execution time can be affected by processor
- Multiple constant time operations can be collectively be considered as 1 constant time operations

**identifying constant time operations**
- Common constant time operations
  - Additions, substractions, multiplication, and division of fixed size numerical values
    - although these operations differ in execution time, they take the same amount of time (constant) regardless of the operand values   
  - variable assignment
  - comparison of 2 fixed size data values
  - array read/write at a particular index
  - A loop with constant number of iterations
    - a loop with variable number of iterations is not a constant time operation since it can take longer or shorter depending on the number of iterations
<details>
  <summary>Constant time vs non-constant time operations</summary>

  ![image](https://user-images.githubusercontent.com/14286113/173057613-c9a9b758-e400-44c3-9bac-276818a3b087.png)
</details>
  
### 2.3 Algorithm Efficiency

**algorithm efficiency**
- measured by algorithm's computational complexity (amount of resources used)
- Resources: runtime and memory usage
  - long runtimes and high memory usage means algorithm is inefficient 

**runtime complexity**
- _T(N)_ function that represents the number of constant time operations performed by algorithm on an input of size `N`
- depends on input data so runtime complexity is evaluated according to best and worst case scenarios

**Best/worst case**
- describes contents of algorithm's input data
  - input data must be variable 
- best case: scenario where the algorithm does the min possible number of operations
- worst case: scenario where the algorithm does max possible number of operations
  -  ex: searching for an element that does not exist in an array
<details>
  <summary>Ex: Linear search best and worst cases</summary>

  ![image](https://user-images.githubusercontent.com/14286113/173144424-ad068856-beda-457e-9a5a-1a1697c12143.png)

</details>

**Space complexity**
- _S(N)_ function that represents the number of fixed-size memory units used by the algorithm for an input of size N
  - includes input data + additional memory for things like loop counters and list pointers
- Auxilary space complexity: space complexity without input data
  - usually is constant since _S(N)_ is dependent on input data (_N_) but auxilary space complexity isn't
<details>
  <summary>Ex: space complexity</summary>
  
  - ![image](https://user-images.githubusercontent.com/14286113/173176867-5778f7ab-b78b-4055-95e1-c7cf1d44427c.png)
</details>

### 2.4 Growth of functions and complexity

**bounds**
- lower bound: _f(N)_ that is less than the best case _T(N)_ for all values of `N >= 1`
- upper bound: _f(N)_ that is greater than the worst case _T(N)_ for all values of `N >= 1`
